---
description: 
globs: 
alwaysApply: true
---
## 🧠 AI Programming Manifesto

This manifesto consolidates all engineering best practices to guide AI-assisted software development. It ensures the AI produces clean, scalable, secure, and maintainable code across the stack. The principles are structured using MECE (Mutually Exclusive, Collectively Exhaustive) design to avoid redundancy and ensure clarity.

---

### 1. 🧼 Clean Code Principles
- Always **prefer simple solutions**.
- Avoid **duplication of code** — check if similar functionality already exists.
- Write **clean, organized code** that’s easy to read and maintain.
- Respect **environment boundaries**: ensure behavior is correct across `dev`, `test`, and `prod`.
- Don’t overwrite `.env` files without asking or confirming.
- Limit files to **200–300 lines**; refactor when needed.
- Avoid stubbing or mocking for `dev` or `prod`; mock data is **only for tests**.

---

### 2. 🧠 Programming Design & Architecture
- Favor **modular, decoupled design** with clear separation of concerns.
- Use **existing patterns or technologies first** before introducing new ones.
- Remove obsolete logic after refactoring to avoid duplication.
- Apply **Open/Closed**, **Single Responsibility**, and **Loose Coupling** principles.

---

### 3. 🧩 API Design Principles
- Choose **REST or GraphQL** with versioning.
- Define contracts using **OpenAPI/Swagger or GraphQL schemas**.
- Enforce **input/output validation** (e.g., Zod, Pydantic).
- Keep endpoints **intuitive and minimal**.

---

### 4. 📦 Package & Dependency Hygiene
- **Pin versions**; avoid using `latest`.
- Regularly audit for **security vulnerabilities**.
- Choose well-maintained libraries with suitable licenses.

---

### 5. 🧪 Testing & Quality Assurance
- Apply **layered testing**: unit > integration > E2E.
- Follow **F.I.R.S.T.**: Fast, Independent, Repeatable, Self-validating, Timely.
- Use **TDD** where applicable.
- Automate testing in CI with 80–90%+ critical path coverage.

---

### 6. 🔍 Code Review Standards
- Enforce **peer reviews** on all mainline merges.
- Prefer **small, purposeful PRs**.
- Focus on **correctness, readability, performance, and security**.

---

### 7. 🔐 Security Best Practices
- Use **MFA, RBAC, and secrets management** tools.
- Sanitize and validate all inputs.
- Use **TLS for transit**, **AES-256 for rest**.
- Scan for vulnerabilities in code and dependencies.

---

### 8. 📊 Observability & Monitoring
- Instrument **logs, metrics, and traces**.
- Use **structured logging** with trace IDs.
- Integrate **health checks**, dashboards (e.g., Grafana), and alerts.

---

### 9. 🚀 CI/CD & DevOps
- Enforce **linting, formatting, and testing** in CI.
- Use **infrastructure-as-code** (e.g., Terraform, Pulumi).
- Automate deployments with **rollback support**.
- Use **Docker, pnpm, Pipenv** for reproducible builds.

---

### 10. 📚 Documentation
- Write **docstrings, READMEs**, and **usage examples**.
- Maintain **architecture overviews** and **ADRs**.
- Document APIs, operations, and deployment processes.

---

### 11. 🗄️ Database Management
- Normalize schemas; denormalize with justification.
- Use **indexes**, **constraints**, and **foreign keys** wisely.
- Apply **versioned migrations** (e.g., Alembic, Prisma Migrate).

---

### 12. ⚡ Performance Optimization
- Profile and benchmark **before optimizing**.
- Optimize **data access patterns** (e.g., pagination, projection).
- Use **async/concurrent execution** when appropriate.

---

### 13. 🎨 Frontend UX Principles
- Design for **performance and responsiveness**.
- Build for **accessibility** and provide **guidance** through the UI.

---

### 14. 🤝 Human-AI Experience (HAX)
- Make capabilities and limitations **clear upfront**.
- Provide **contextual feedback** and **error recovery** options.
- Empower users to **override AI behavior**.

---

These principles ensure that AI-generated code reflects thoughtful architecture, clean structure, secure defaults, and production readiness from the start.

For prototypes don't follow everything. Only adhere to the following:

## 🧪 AI Programming Manifesto for Prototyping

This manifesto outlines how AI should behave during the prototyping phase of product development. It favors speed, clarity, functionality, and lean thinking — helping you validate ideas quickly with minimal technical debt.

---

### 🎯 1. Build for Functionality First
- Prioritize **core logic, integrations, and workflows**.
- Skip UI details unless they are part of the critical path.
- Focus on **making things work**, not making them beautiful — yet.

---

### ⚡ Move Fast, Think Smart
- Use **simple, fast-to-implement solutions**.
- Avoid abstractions, generalizations, or architecture unless necessary.
- Choose known patterns and tools to **minimize uncertainty**.

---

### 🧩 Isolate the Scope
- Work only on the **features defined for this prototype**.
- Avoid refactoring or touching unrelated code.
- Keep the footprint small and modular.

---

### 🔄 Embrace Temporary Code (Intentionally)
- It's okay to:
  - Hardcode values
  - Use mock services
  - Simplify state flows
  - Bypass error handling
- As long as it's **clearly marked and isolated**, and **delivers the outcome**.

---

### 🧪 Write Lean Tests
- Cover **main happy paths**.
- Mock or skip dependencies that aren’t being validated.
- Focus on validating **core assumptions**.

---

### 📚 Document Assumptions and Gaps
- Clearly annotate:
  - TODOs for missing components
  - Shortcuts taken (e.g., static data, mocked APIs)
  - Known edge cases not handled yet

---

### 🔌 Favor Local & Lightweight
- Run models, services, and tools **locally or via lightweight services**.
- Avoid long setup times, cloud lock-in, or unnecessary configs.

---

### 📦 Keep It Disposable
- Treat prototype code as **throwaway unless validated**.
- If proven valuable, **refactor before reuse**.
- Avoid porting unrefined logic directly into production.

---

### ✅ End Criteria for Prototype Completion
- The prototype **demonstrates core functionality**.
- You can test the idea, user interaction, or integration.
- There’s enough clarity to justify moving to the next phase (e.g., UI polish, architecture).

---

## 🧰 Must-Have Components for Every Prototype

### ✅ Coding Practices
- Use **clean, readable code** even when moving fast.
- Comment important decisions or shortcuts.
- Organize files into clear modules/components.
- Stick to consistent naming and formatting (use Prettier, Black, ESLint).

### 🎨 Design Elements (Minimum UI)
- Use **Tailwind CSS** or **Chakra UI** for quick styling.
- Focus on layout, flows, and feedback — not pixel-perfection.
- Include minimal loading states and error boundaries.

### 🧪 Testing Practices
- Include **basic unit tests** for main logic and flows.
- Mock AI APIs, DB access, and external calls.
- Use Vitest, Jest, or Pytest for test speed and simplicity.

### 🛠️ Tech Stack
- **Frontend**: React + Vite/Next.js, Tailwind CSS, TypeScript
- **Mobile**: React Native (with Expo)
- **Backend**: FastAPI (Python) or Node.js + Express/Fastify
- **Gen AI**: OpenAI API, LangChain, Pinecone/FAISS for embeddings
- **DB/Storage**: PostgreSQL (with Prisma or SQLAlchemy), Redis, local JSON or SQLite for prototypes
- **CI/CD**: GitHub Actions (optional, only if deployed)

---

By following this manifesto, AI becomes your fastest path from idea to working proof — without overengineering or wasting cycles, and with enough discipline to scale what works.


